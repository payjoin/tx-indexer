use bitcoin::Amount;

use crate::abstract_types::AbstractTxHandle;
use crate::abstract_types::EnumerateOutputValueInArbitraryOrder;
use crate::abstract_types::EnumerateSpentTxOuts;
use crate::abstract_types::OutputCount;
use crate::abstract_types::TxConstituent;
use crate::storage::InMemoryIndex;

// Type defintions for loose txs and their ids

// TBD whether this is a generic or u32 specifically
/// Sum of the short id of the txid and vout.
#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]
pub struct TxOutId {
    pub txid: TxId,
    pub vout: u32,
}

impl TxOutId {
    pub fn new(txid: TxId, vout: u32) -> Self {
        Self { txid, vout }
    }
}

impl TxOutId {
    fn with<'a>(&self, index: &'a InMemoryIndex) -> TxOutHandle<'a> {
        TxOutHandle { id: *self, index }
    }
}

pub struct TxOutHandle<'a> {
    id: TxOutId,
    index: &'a InMemoryIndex,
}

impl<'a> TxOutHandle<'a> {
    // TODO: this new should exist. You always get a handle from the id.
    pub fn new(id: TxOutId, index: &'a InMemoryIndex) -> Self {
        Self { id, index }
    }

    pub fn id(&self) -> TxOutId {
        self.id
    }

    pub fn tx(&self) -> TxHandle<'a> {
        self.id.txid.with(self.index)
    }

    pub fn amount(&self) -> Amount {
        self.index
            .txs
            .get(&self.id.txid)
            .expect("Tx should always exist")
            .output[self.id.vout as usize]
            .value
    }

    pub fn vout(&self) -> u32 {
        self.id.vout
    }
}

/// Sum of the short id of the txid and vin
#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]
pub struct TxInId {
    txid: TxId,
    vin: u32,
}

impl TxInId {
    fn with<'a>(&self, index: &'a InMemoryIndex) -> TxInHandle<'a> {
        TxInHandle { id: *self, index }
    }
}

pub struct TxInHandle<'a> {
    id: TxInId,
    index: &'a InMemoryIndex,
}

#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]
pub struct TxId(pub u32);

impl TxId {
    pub fn with<'a>(&self, index: &'a InMemoryIndex) -> TxHandle<'a> {
        TxHandle::new(*self, index)
    }

    // TODO: this should not be pub. Only pub'd for testing purposes.
    pub fn txout_id(&self, vout: u32) -> TxOutId {
        TxOutId { txid: *self, vout }
    }

    pub fn txin_id(&self, vin: u32) -> TxInId {
        TxInId { txid: *self, vin }
    }

    fn txout_handle<'a>(&self, index: &'a InMemoryIndex, vout: u32) -> TxOutHandle<'a> {
        self.txout_id(vout).with(index)
    }

    fn txin_handle<'a>(&self, index: &'a InMemoryIndex, vin: u32) -> TxInHandle<'a> {
        self.txin_id(vin).with(index)
    }
}

pub struct TxHandle<'a> {
    id: TxId,
    index: &'a InMemoryIndex,
}

impl<'a> TxHandle<'a> {
    pub fn new(id: TxId, index: &'a InMemoryIndex) -> Self {
        Self { id, index }
    }

    pub fn id(&self) -> TxId {
        self.id
    }

    fn spent_coins(&self) -> impl Iterator<Item = TxOutId> {
        self.index
            .prev_txouts
            .iter()
            .map(|(_, outid)| outid.clone())
    }

    pub fn outputs(&self) -> impl Iterator<Item = TxOutHandle<'a>> {
        let outputs_len = self
            .index
            .txs
            .get(&self.id)
            .expect("If I have a handle it must exist?")
            .output
            .len();
        (0..outputs_len)
            .into_iter()
            .map(|i| self.id.txout_handle(self.index, i as u32))
    }

    pub fn output_count(&self) -> usize {
        self.id.with(self.index).outputs().count()
    }
}

impl AbstractTxHandle for TxHandle<'_> {
    fn id(&self) -> TxId {
        self.id
    }
}

impl<'a> TxConstituent for TxOutHandle<'a> {
    type Handle = TxHandle<'a>;
    fn containing_tx(&self) -> Self::Handle {
        self.tx()
    }

    fn index(&self) -> usize {
        self.id.vout as usize
    }
}

impl OutputCount for TxHandle<'_> {
    fn output_count(&self) -> usize {
        self.output_count()
    }
}

// TODO: this should be a handle type generated by the handle
// TODO: also need an abstract transaction Data struct
impl<'a> EnumerateSpentTxOuts for TxHandle<'a> {
    fn spent_coins(&self) -> impl Iterator<Item = TxOutId> {
        self.spent_coins()
    }
}

impl<'a> EnumerateOutputValueInArbitraryOrder for TxHandle<'a> {
    fn output_values(&self) -> impl Iterator<Item = Amount> {
        self.outputs().map(|output| output.amount())
    }
}
