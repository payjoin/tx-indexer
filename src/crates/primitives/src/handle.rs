use crate::{
    ScriptPubkeyHash,
    abstract_fingerprints::HasNLockTime,
    abstract_types::{
        AbstractTransaction, EnumerateOutputValueInArbitraryOrder, EnumerateSpentTxOuts,
        OutputCount, TxConstituent,
    },
    graph_index::IndexedGraph,
    loose::storage::InMemoryIndex,
    loose::{TxId, TxInId, TxOutId},
};

use bitcoin::Amount;
pub struct TxHandle<'a> {
    id: TxId,
    index: &'a dyn IndexedGraph,
}

impl<'a> TxHandle<'a> {
    pub fn new(id: TxId, index: &'a dyn IndexedGraph) -> Self {
        Self { id, index }
    }

    pub fn id(&self) -> TxId {
        self.id
    }

    fn spent_coins(&self) -> impl Iterator<Item = TxOutId> {
        self.inputs().map(|input| input.prev_txout_id())
    }

    pub fn outputs(&self) -> impl Iterator<Item = TxOutHandle<'a>> {
        let outputs_len = self
            .index
            .tx(&self.id)
            .expect("If I have a handle it must exist?")
            .output_len();
        (0..outputs_len).map(|i| self.id.txout_id(i as u32).with(self.index))
    }

    pub fn output_count(&self) -> usize {
        self.id.with(self.index).outputs().count()
    }

    pub fn is_coinbase(&self) -> bool {
        self.spent_coins().count() == 0
    }

    pub fn change_vout(&self) -> Option<u32> {
        unimplemented!()
    }

    pub fn inputs_are_clustered(&self) -> bool {
        let inputs = self.spent_coins().collect::<Vec<_>>();
        if inputs.is_empty() {
            return false;
        }
        let first_root = self.index.find(inputs[0]);
        inputs.iter().all(|input| {
            let other = self.index.find(*input);

            other == first_root
        })
    }
}

impl AbstractTransaction for TxHandle<'_> {
    fn id(&self) -> TxId {
        self.id
    }

    // TODO: are these expects correct when in a pruned node
    // TODO: this hsould be returning an Arc pointer not allocated box
    fn inputs(
        &self,
    ) -> Box<dyn Iterator<Item = Box<dyn crate::abstract_types::AbstractTxIn>> + '_> {
        let tx = self
            .index
            .tx(&self.id)
            .expect("Tx should always exist if we have a handle");
        let input_boxes: Vec<Box<dyn crate::abstract_types::AbstractTxIn>> = tx.inputs().collect();
        Box::new(input_boxes.into_iter())
    }

    // TODO: this should be returning an Arc pointer not allocated box
    fn outputs(
        &self,
    ) -> Box<dyn Iterator<Item = Box<dyn crate::abstract_types::AbstractTxOut>> + '_> {
        let tx = self
            .index
            .tx(&self.id)
            .expect("Tx should always exist if we have a handle");
        let output_boxes: Vec<Box<dyn crate::abstract_types::AbstractTxOut>> =
            tx.outputs().collect();
        Box::new(output_boxes.into_iter())
    }

    fn output_len(&self) -> usize {
        self.index
            .tx(&self.id)
            .expect("Tx should always exist if we have a handle")
            .output_len()
    }

    fn output_at(&self, index: usize) -> Option<Box<dyn crate::abstract_types::AbstractTxOut>> {
        // Delegate to the stored transaction in the index
        self.index
            .tx(&self.id)
            .expect("Tx should always exist if we have a handle")
            .output_at(index)
    }

    fn locktime(&self) -> u32 {
        self.index
            .tx(&self.id)
            .expect("Tx should always exist if we have a handle")
            .locktime()
    }
}

impl<'a> TxConstituent for TxOutHandle<'a> {
    type Handle = TxHandle<'a>;
    fn containing_tx(&self) -> Self::Handle {
        self.tx()
    }

    fn vout(&self) -> usize {
        self.id.vout as usize
    }
}

impl OutputCount for TxHandle<'_> {
    fn output_count(&self) -> usize {
        self.output_count()
    }
}

// TODO: this should return a handle type generated by the handle
impl<'a> EnumerateSpentTxOuts for TxHandle<'a> {
    fn spent_coins(&self) -> impl Iterator<Item = TxOutId> {
        self.spent_coins()
    }
}

impl<'a> EnumerateOutputValueInArbitraryOrder for TxHandle<'a> {
    fn output_values(&self) -> impl Iterator<Item = Amount> {
        self.outputs().map(|output| output.amount())
    }
}

impl<'a> HasNLockTime for TxHandle<'a> {
    fn n_locktime(&self) -> u32 {
        self.index
            .tx(&self.id)
            .expect("Tx should always exist if we have a handle")
            .locktime()
    }
}

pub struct TxInHandle<'a> {
    id: TxInId,
    index: &'a dyn IndexedGraph,
}

impl<'a> TxInHandle<'a> {
    pub fn new(id: TxInId, index: &'a dyn IndexedGraph) -> Self {
        Self { id, index }
    }

    pub fn id(&self) -> TxInId {
        self.id
    }

    pub fn tx(&self) -> TxHandle<'a> {
        self.id.txid.with(self.index)
    }
}

pub struct ClusterHandle<'a> {
    txout_id: TxOutId,
    index: &'a InMemoryIndex,
    // TODO: this is specific for global clustering. not any particular clustering fact.
    // Should specify which disjoin sets structure it is using.
}

impl<'a> ClusterHandle<'a> {
    pub fn new(txout_id: TxOutId, index: &'a InMemoryIndex) -> Self {
        Self { txout_id, index }
    }

    pub fn iter_txouts(&self) -> impl Iterator<Item = TxOutHandle<'a>> {
        self.index
            .global_clustering
            .iter_set(self.txout_id)
            .map(|txout_id| txout_id.with(self.index))
    }
}

pub struct TxOutHandle<'a> {
    id: TxOutId,
    index: &'a dyn IndexedGraph,
}

impl<'a> TxOutHandle<'a> {
    // TODO: this new should exist. You always get a handle from the id.
    pub fn new(id: TxOutId, index: &'a dyn IndexedGraph) -> Self {
        Self { id, index }
    }

    pub fn id(&self) -> TxOutId {
        self.id
    }

    pub fn tx(&self) -> TxHandle<'a> {
        self.id.txid.with(self.index)
    }

    pub fn amount(&self) -> Amount {
        self.index
            .tx(&self.id.txid)
            .expect("Tx should always exist")
            .output_at(self.id.vout as usize)
            .expect("Output should always exist")
            .value()
    }

    pub fn vout(&self) -> u32 {
        self.id.vout
    }

    pub fn spent_by(&self) -> Option<TxInHandle<'a>> {
        self.index
            .spending_txin(&self.id)
            .map(|txin_id| txin_id.with(self.index))
    }

    pub fn script_pubkey_hash(&self) -> ScriptPubkeyHash {
        self.index
            .tx(&self.id.txid)
            .expect("Tx should always exist")
            .output_at(self.id.vout as usize)
            .expect("Output should always exist")
            .script_pubkey_hash()
    }
}
