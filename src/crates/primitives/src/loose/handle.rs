use crate::{
    ScriptPubkeyHash,
    abstract_fingerprints::HasNLockTime,
    abstract_types::{
        AbstractTransaction, AbstractTxIn, AbstractTxOut, EnumerateOutputValueInArbitraryOrder,
        EnumerateSpentTxOuts, IdFamily, OutputCount, TxConstituent,
    },
    graph_index::IndexedGraph,
    loose::{LooseIds, TxId, TxInId, TxOutId, storage::InMemoryIndex},
};

use bitcoin::Amount;
/// Type alias for the indexed graph; the lifetime ties the trait object to the reference.
pub type LooseIndexedGraph<'a> = dyn IndexedGraph<LooseIds> + 'a;

pub struct TxHandle<'a> {
    id: TxId,
    index: &'a LooseIndexedGraph<'a>,
}

impl<'a> TxHandle<'a> {
    pub fn new(id: TxId, index: &'a LooseIndexedGraph<'a>) -> Self {
        Self { id, index }
    }

    pub fn id(&self) -> TxId {
        self.id
    }

    fn spent_coins(&self) -> impl Iterator<Item = TxOutId> {
        let tx = self
            .index
            .tx(&self.id.into())
            .expect("Tx should always exist if we have a handle");
        // TODO collect is a hack around lifetime issues.
        tx.spent_coins().collect::<Vec<_>>().into_iter()
    }

    pub fn outputs(&self) -> impl Iterator<Item = TxOutHandle<'a>> {
        let outputs_len = self
            .index
            .tx(&self.id.into())
            .expect("If I have a handle it must exist?")
            .output_len();
        (0..outputs_len).map(|i| self.id.txout_id(i as u32).with(self.index))
    }

    pub fn output_count(&self) -> usize {
        self.id.with(self.index).outputs().count()
    }

    pub fn is_coinbase(&self) -> bool {
        self.spent_coins().count() == 0
    }

    pub fn inputs_are_clustered(&self) -> bool {
        let inputs = self.spent_coins().collect::<Vec<_>>();
        if inputs.is_empty() {
            return false;
        }
        let first_root = self.index.find(inputs[0].into());
        inputs.iter().all(|input| {
            let other = self.index.find((*input).into());

            other == first_root
        })
    }
}

impl AbstractTransaction for TxHandle<'_> {
    type I = LooseIds;
    fn id(&self) -> <Self::I as IdFamily>::TxId {
        self.id
    }

    // TODO: are these expects correct when in a pruned node
    // TODO: this hsould be returning an Arc pointer not allocated box
    fn inputs(&self) -> Box<dyn Iterator<Item = Box<dyn AbstractTxIn<I = Self::I>>> + '_> {
        let tx = self
            .index
            .tx(&self.id)
            .expect("Tx should always exist if we have a handle");
        // TODO: is this not a infinite loop?
        let input_boxes: Vec<Box<dyn AbstractTxIn<I = Self::I>>> = tx.inputs().collect();
        Box::new(input_boxes.into_iter())
    }

    // TODO: this should be returning an Arc pointer not allocated box
    fn outputs(&self) -> Box<dyn Iterator<Item = Box<dyn AbstractTxOut<I = Self::I>>> + '_> {
        let tx = self
            .index
            .tx(&self.id.into())
            .expect("Tx should always exist if we have a handle");
        // TODO: is this not a infinite loop?
        let output_boxes: Vec<Box<dyn AbstractTxOut<I = Self::I>>> = tx.outputs().collect();
        Box::new(output_boxes.into_iter())
    }

    fn output_len(&self) -> usize {
        self.index
            .tx(&self.id.into())
            .expect("Tx should always exist if we have a handle")
            .output_len()
    }

    fn output_at(&self, index: usize) -> Option<Box<dyn AbstractTxOut<I = Self::I>>> {
        // Delegate to the stored transaction in the index
        self.index
            .tx(&self.id.into())
            .expect("Tx should always exist if we have a handle")
            .output_at(index)
    }

    fn locktime(&self) -> u32 {
        self.index
            .tx(&self.id.into())
            .expect("Tx should always exist if we have a handle")
            .locktime()
    }
}

impl<'a> TxConstituent for TxOutHandle<'a> {
    type Handle = TxHandle<'a>;
    fn containing_tx(&self) -> Self::Handle {
        self.tx()
    }

    // TODO: why usize cast here?
    fn vout(&self) -> usize {
        self.id.vout() as usize
    }
}

impl OutputCount for TxHandle<'_> {
    fn output_count(&self) -> usize {
        self.output_count()
    }
}

// TODO: this should return a handle type generated by the handle
impl<'a> EnumerateSpentTxOuts for TxHandle<'a> {
    fn spent_coins(&self) -> impl Iterator<Item = TxOutId> {
        self.spent_coins()
    }
}

impl<'a> EnumerateOutputValueInArbitraryOrder for TxHandle<'a> {
    fn output_values(&self) -> impl Iterator<Item = Amount> {
        self.outputs().map(|output| output.amount())
    }
}

impl<'a> HasNLockTime for TxHandle<'a> {
    fn n_locktime(&self) -> u32 {
        self.index
            .tx(&self.id.into())
            .expect("Tx should always exist if we have a handle")
            .locktime()
    }
}

pub struct TxInHandle<'a> {
    id: TxInId,
    index: &'a LooseIndexedGraph<'a>,
}

impl<'a> TxInHandle<'a> {
    pub fn new(id: TxInId, index: &'a LooseIndexedGraph<'a>) -> Self {
        Self { id, index }
    }

    pub fn id(&self) -> TxInId {
        self.id
    }

    pub fn tx(&self) -> TxHandle<'a> {
        self.id.txid().with(self.index)
    }
}

impl<'a> AbstractTxIn for TxInHandle<'a> {
    type I = LooseIds;
    fn prev_txid(&self) -> <Self::I as IdFamily>::TxId {
        self.index.prev_txout(&self.id).txid()
    }
    fn prev_vout(&self) -> u32 {
        self.index.prev_txout(&self.id).vout()
    }

    fn prev_txout_id(&self) -> <Self::I as IdFamily>::TxOutId {
        self.index.prev_txout(&self.id)
    }
}

pub struct ClusterHandle<'a> {
    txout_id: TxOutId,
    index: &'a InMemoryIndex,
    // TODO: this is specific for global clustering. not any particular clustering fact.
    // Should specify which disjoin sets structure it is using.
}

impl<'a> ClusterHandle<'a> {
    pub fn new(txout_id: TxOutId, index: &'a InMemoryIndex) -> Self {
        Self { txout_id, index }
    }

    pub fn iter_txouts(&self) -> impl Iterator<Item = TxOutHandle<'a>> {
        self.index
            .global_clustering
            .iter_set(self.txout_id)
            .map(|txout_id| txout_id.with(self.index))
    }
}

pub struct TxOutHandle<'a> {
    id: TxOutId,
    index: &'a LooseIndexedGraph<'a>,
}

impl<'a> TxOutHandle<'a> {
    // TODO: this new should exist. You always get a handle from the id.
    pub fn new(id: TxOutId, index: &'a LooseIndexedGraph<'a>) -> Self {
        Self { id, index }
    }

    pub fn id(&self) -> TxOutId {
        self.id
    }

    pub fn tx(&self) -> TxHandle<'a> {
        self.id.txid().with(self.index)
    }

    pub fn amount(&self) -> Amount {
        self.index
            .tx(&self.id.txid().into())
            .expect("Tx should always exist")
            .output_at(self.id.vout() as usize)
            .expect("Output should always exist")
            .value()
    }

    pub fn vout(&self) -> u32 {
        self.id.vout()
    }

    pub fn spent_by(&self) -> Option<TxInHandle<'a>> {
        self.index
            .spending_txin(&self.id.into())
            .map(|txin_id| txin_id.with(self.index))
    }

    pub fn script_pubkey_hash(&self) -> ScriptPubkeyHash {
        self.index
            .tx(&self.id.txid().into())
            .expect("Tx should always exist")
            .output_at(self.id.vout() as usize)
            .expect("Output should always exist")
            .script_pubkey_hash()
    }
}

impl<'a> AbstractTxOut for TxOutHandle<'a> {
    type I = LooseIds;
    fn id(&self) -> <Self::I as IdFamily>::TxOutId {
        self.id
    }

    fn value(&self) -> Amount {
        self.amount()
    }

    fn script_pubkey_hash(&self) -> ScriptPubkeyHash {
        self.script_pubkey_hash()
    }
}
